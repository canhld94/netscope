// Generated by CoffeeScript 1.4.0
(function() {
  var Analyzer, CaffeParser, Network, Parser, generateLayers, generateNetwork,
    __hasProp = {}.hasOwnProperty;

  Parser = require('./parser');

  Network = require('../network.coffee');

  Analyzer = require('../analyzer.coffee');

  generateLayers = function(descriptors, phase) {
    var entry, headerKeys, layer, layerDesc, layers, _i, _len;
    if (phase == null) {
      phase = 'train';
    }
    layers = [];
    for (_i = 0, _len = descriptors.length; _i < _len; _i++) {
      entry = descriptors[_i];
      layerDesc = entry.layer || entry.layers;
      if (layerDesc != null) {
        layer = {};
        headerKeys = ['name', 'type', 'top', 'bottom'];
        _.extend(layer, _.pick(layerDesc, headerKeys));
        layer.attribs = _.omit(layerDesc, headerKeys);
        layers.push(layer);
      } else {
        console.log('Unidentified entry ignored: ', entry);
      }
    }
    layers = _.filter(layers, function(layer) {
      var layerPhase, _ref;
      layerPhase = (_ref = layer.attribs.include) != null ? _ref.phase : void 0;
      return !((layerPhase != null) && layerPhase !== phase);
    });
    return layers;
  };

  generateNetwork = function(layers, header) {
    var children, curNode, dataNode, dims, getNodes, getSingleNode, i, implicitLayers, inplaceChild, inplaceOps, inplaceTable, input, inputs, k, layer, net, node, nodeTable, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref,
      _this = this;
    nodeTable = {};
    implicitLayers = [];
    net = new Network(header.name);
    getSingleNode = function(name) {
      var node;
      node = nodeTable[name];
      if (!(node != null)) {
        debugger;
        node = net.createNode(name, 'implicit');
        nodeTable[name] = node;
      }
      return node;
    };
    getNodes = function(names, exclude) {
      names = [].concat(names);
      if (exclude != null) {
        _.pullAll(names, exclude);
      }
      return _.map(names, getSingleNode);
    };
    for (_i = 0, _len = layers.length; _i < _len; _i++) {
      layer = layers[_i];
      nodeTable[layer.name] = net.createNode(layer.name, layer.type, layer.attribs, {});
    }
    inplaceTable = {};
    for (_j = 0, _len1 = layers.length; _j < _len1; _j++) {
      layer = layers[_j];
      node = nodeTable[layer.name];
      if (layer.top != null) {
        if (layer.top === layer.bottom) {
          if (!(inplaceTable[layer.top] != null)) {
            inplaceTable[layer.top] = [];
          }
          inplaceTable[layer.top].push(node);
          continue;
        } else {
          node.addChildren(getNodes(layer.top, [layer.name]));
        }
      }
      if (layer.bottom != null) {
        node.addParents(getNodes(layer.bottom, [].concat(layer.top)));
      }
    }
    for (k in inplaceTable) {
      if (!__hasProp.call(inplaceTable, k)) continue;
      inplaceOps = inplaceTable[k];
      curNode = nodeTable[k];
      curNode.coalesce = inplaceOps;
      children = curNode.detachChildren();
      for (_k = 0, _len2 = inplaceOps.length; _k < _len2; _k++) {
        inplaceChild = inplaceOps[_k];
        inplaceChild.annotation = 'InPlace';
        curNode.addChild(inplaceChild);
        curNode = inplaceChild;
      }
      curNode.addChildren(children);
    }
    if (((header != null ? header.input : void 0) != null) && (((header != null ? header.input_dim : void 0) != null) || ((header != null ? (_ref = header.input_shape) != null ? _ref.dim : void 0 : void 0) != null))) {
      inputs = [].concat(header.input);
      dims = header.input_dim || header.input_shape.dim;
      if (inputs.length === (dims.length * 0.25)) {
        for (i = _l = 0, _len3 = inputs.length; _l < _len3; i = ++_l) {
          input = inputs[i];
          dataNode = nodeTable[input];
          dataNode.type = 'data';
          dataNode.attribs.input_param = {
            shape: {
              dim: dims.slice(i * 4, (i + 1) * 4)
            }
          };
        }
      } else {
        console.log('Inconsistent input dimensions.');
      }
    }
    return net;
  };

  module.exports = CaffeParser = (function() {

    function CaffeParser() {}

    CaffeParser.parse = function(txt, phase) {
      var NetworkAnalyzer, header, layerDesc, layers, network, _ref;
      _ref = Parser.parse(txt), header = _ref[0], layerDesc = _ref[1];
      if ((layerDesc[0].input_dim != null) || (layerDesc[0].input_shape != null)) {
        _.extend(header, layerDesc[0]);
      }
      layers = generateLayers(layerDesc, phase);
      network = generateNetwork(layers, header);
      NetworkAnalyzer = new Analyzer();
      network = NetworkAnalyzer.analyze(network);
      return network;
    };

    return CaffeParser;

  })();

}).call(this);
